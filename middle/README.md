# 💎파이썬에 대해💎
* 파이썬은 인터프리터 언어  
* 코드가 길어지고 복잡해지면 인터프리트 모드는 번거롭다.  
	* 따라서 스크립트 모드(소스파일 만들어서 전체 실행 하는 것)로 바꿈.

# 💍컴퓨터 구조론💍
![image](https://user-images.githubusercontent.com/77817094/195242606-2f6201a6-bf5b-4649-b479-5f5307560168.png)
하드웨어는 컴퓨터를 구성하는 기계적 장치이며,
소프트웨어는 하드웨어의 동작을 지시하고 제어하는 명령어의 집합이다.

## 하드웨어
**CPU란❓**  
```중앙 처리 장치```  
컴퓨터 시스템의 논리적 구성요소로 모든 장치의 동작을 제어하고 명령을 실행 하는 장치이다. (사람으로 치면 뇌🧠)  
내부적으로 3가지로 나눌 수 있다.
* 연산을 수행하는 산술논리장치(ALU)  
* 제어 명령을 전달하는 컨트롤 장치(CU)  
* 결과 값을 일시적으로 기억하는 레지스터(Register)
* ![image](https://user-images.githubusercontent.com/77817094/195243357-ab109d4b-4b61-4b64-b107-987ff33e5fc9.png)

제어장치와 연산장치의 동작 과정
1. 먼저 제어장치가 기억장치로부터 명령어를 가져옵니다(Fetch).
2. 제어장치는 가져온 명령어를 해독(Decode)합니다.
3. 제어장치는 해독한 명령어에 따라 산술논리장치에 데이터를 옮기고 어떤 연산을 수행할지를 지시합니다.
4. 산술논리장치는 제어장치가 지시한 대로 계산을 수행(Execute)합니다.
5. 그리고 수행한 결과를 기억장치에 다시 저장(Store)합니다.


**Memory란❓**  
주기억장치  
```
CPU의 Register의 용량은 매우 작아서 정보를 저장해 두었다가 필요할 때 읽어 들여 이용할 수 있는 주 기억 장치가 필요하다. 컴퓨터가 켜지면 운영체제, 사용자 프로그램등이 주 기억 장치의 메모리공간에 올라가게 된다. CPU는 주 기억 장치에서 프로그램들의 명령어등을 읽어와 작업을 수행한다. 대표적으로 ROM과 RAM으로 나누어 짐.
```
ROM  
``` Read Only Memory ```  
* 오직 데이터를 읽기만 가능함.
* 전원이 끊어져도 데이터들이 소멸되지 않는 비휘발성 메모리.  
* 데이터를 저장한 후 반영구적으로 사용 가능.  

RAM  
``` Random Access Memory ```  
* 읽고 쓰기가 가능  
* 응용 프로그램, OS등을 불러와 CPU가 작업할 수 있도록 하는 기억장치
* 전원이 끊어지면 데이터가 전부 지워지는 휘발성 메모리.
	* 따라서 실행하고 있는 파일은 항상 보조기억장치에 저장을 해줘야 함.

그 밖에
* CPU와 주기억장치 사이의 속도 차이를 완화시키기 위해 고속 버퍼(임시)메모리로, 캐시메모리가 존재함.
* ![image](https://user-images.githubusercontent.com/77817094/195245620-55d7fbd2-d747-4251-959e-916f633e5da7.png) 속도가 빠를 수록 크기가 작은 것을 볼 수 있다.

흐름
![image](https://user-images.githubusercontent.com/77817094/195246760-dfdf372b-ba53-4054-953a-f736a53637f0.png)
![image](https://user-images.githubusercontent.com/77817094/195246566-e9d608d5-c791-42b0-9590-2bc0ce556188.png)
```
1. 컴퓨터에 전원이 들어오게 되면 메인 메모리에 운영체제가 올라간다. 이때 모든 운영체제 코드가 올라가는게아니라 시스템이 돌아가기위한 핵심적인 부분이 먼저올라가는데 이부분을 커널이라 한다. 이러한 이유는 모든 코드가 메모리에 올리게되면 자원낭비가 심하기 때문이다.

2. 그 이후에 CPU는 메모리의 운영체제 프로그램들을 읽어 운영체제를 실행한다. 운영체제가 시작되고 다른 프로그램들을 실행시키면 마찬가지로 메인메모리에 올라가게 된다. 

3. 이때 CPU는 메인메모리에 명령어 주소를 레지스터에 저장하는데 이 레지스터 이름은 PC레지스터라 한다. 

4. 그 이후 각각의 프로그램들은 I/O 디바이스 사용이 필요할 수 있는데 이러한 요청은 운영체제한테 해야한다. 이러한 요청을 시스템콜이라고 한다. 이렇게 프로그램들이 직접 I/O디바이스를 제어하지 않는 이유는 많은 이유가있지만 가장 큰 이유는 보안 때문이다.

5. 프로그램의 요청을 받은 운영체제는 I/O 디바이스의 컨트롤러에게 데이터 입출력 처리를 요청을 한다. 그리고 I/O 디바이스 컨 틀롤러들은 입출력을 받게 되면 Interrupt를 발생시켜 CPU에게 작업이 완료됐다고 알리게 된다.

6. CPU는 I/O 디바이스에 버퍼에 가서 데이터를 읽어와 메인 메모리에 올려놓게 된다. 이러한 작업이 반복되는 것이 컴퓨터 프로그램의 동작 원리이다. 
```

# **✨리스트, 튜플, 딕셔너리✨**
> 개 중요함.
## 리스트✏
``` 데이터의 목록을 다루는 자료형 ```
slot: 리스트의 데이터를 넣을 자리.  
element: 슬롯에 꽂혀있는 개별 데이터.  
리스트 만들 때는 대괄호 사용
* 각 데이터는 콤마로 구분(['a','b','c'] 이런 식)
* '+' 연산자로 리스트 간 결합 가능
* 슬라이싱: [2:5] = 2,3,4 [:4] = 0,1,2,3 [5:] = 5부터 끝까지
* len(리스트) 넣으면 데이터 갯수 나옴
* a[2] = 20으로 데이터 변경 가능  

### **메소드**
+ .append()
	+ 리스트 끝에 새 요소 추가  
+ .extend()
	+ 리스트에 다른 리스트 이어 붙임  
+ .insert()
	+ a.insert(2, 4) 2번 인덱스 위치에 4 집어넣음  
+ .remove()
	+ 매개변수로 입력한 데이터를 찾아서 제거  
	+ a.remove('hello')
+ .pop()
	+ a.pop() 마지막 요소를 뽑아서 제거함.  
	+ a.pop(2) 인덱스 입력해도 제거 됨  
+ .index()
	+ a.index('banana') 매개변수로 들어온 값의 인덱스 위치 찾아줌.  
+ .count()
	+ 매개변수로 입력한 데이터와 일치하는 요소가 몇개인지 셈  
+ .sort()
	+ 오름차순으로 정렬  
	+ .sort(reverse = True) 내림차순으로 정렬  
+ .reverse()
	+ 요소의 순서를 반대로 뒤집음 [안녕요] -> [요녕안]  

## **✨🧨리스트와 튜플의 차이🧨✨**
1. list는 데이터 변경 가능하다.  
	+ list 생성 후 추가, 수정, 삭제 가능.  
2. tuple은 데이터 변경이 불가능하다.  
	+ 튜플 생성 후 추가, 수정, 삭제 불가능.  
3. list는 이름 그대로 목록 형식의 데이터를 다루는 데 적합하다.  
4. tuple은 RGB 색상처럼 작은 규모의 자료구조를 구성하기에 적합하다.  

## 튜플✏
``` N개의 요소로 된 집합 ```  
변경이 불가능한 자료형이 필요한 이유?  
> 데이터를 할당할 공간의 내용이나 크기가 달라지지 않기 때문.  
> 데이터가 오염되지 않을 것이라는 보장이 있어서 원본 사용 가능함.  
> 신뢰가 가능한 코드.  

튜플 만들 때는 ()괄호나 , 사용
* a = (1, 2, 3) or a = 1, 2, 3
	* 요소가 하나면 뒤에 , 추가  
	* a = (1, ) or a = 1,
* '+' 연산자로 튜플 간 결합 가능
* 슬라이싱: [2:5] = 2,3,4 [:4] = 0,1,2,3 [5:] = 5부터 끝까지
* a[2] = 20 이런 식인 데이터 변경 불가능 
* len(리스트) 넣으면 데이터 갯수 나옴  

```python
#튜플생성: 패킹
a = 1, 2, 3 
#튜플 언패킹
one, two, three = a
# 요소의 수와 변수의 갯수가 일치해야 함
```
### **메소드**
+ .index()
	+ a.index('banana') 매개변수로 들어온 값의 인덱스 위치 찾아줌.  
+ .count()
	+ 매개변수로 입력한 데이터와 일치하는 요소가 몇개인지 셈

## 딕셔너리✏  
``` 사용법 측면에선 리스트와 비슷 ```  
리스트는 인덱스(0부터 시작)를 첨자처럼 사용하지만 딕셔너리는 어떤 자료형이든 첨자로 사용 가능하다.
* 딕셔너리의 첨자는 키(key)  
* 이 key가 가리키는 슬롯에 있는 데이터를 value라고 한다.  
* 딕셔너리는 key-value의 쌍으로 구성    
* 탐색 속도가 빠르고, 사용하기 편리  
* 딕셔너리 생성할땐 { } 사용  
* 요소 참조하거나, 새로운 키-벨류 입력할 때 [ ] 사용

```python
 #딕셔너리 생성
student1 = {'이름': '홍길동', '학번': '2018112151'}
#키-벨류 추가
student1['학과'] = '열공학과' 
student1['연락처'] = '010-1111-1111'
```
### **메소드**
+ .get(key)
	+ value 값을 찾아 줌.
	+ key가 없을 때 아무것도 반환 안함.
+ .keys(), .values()
	+ 데이터 뭐가 있는지 알려 줌.
+ .items()
	+ 전체적으로 뭐 있는지 알려 줌.
+ 'apple' in fruits.keys() or .values()
	+ boolean 형식으로 존재 여부 알려줌
+ .pop(key)
	+ 그 키의 요소(키,벨류)를 삭제함.
+ .clear()
	+ 딕셔너리 내용 다 없어짐.
+ for문으로 딕셔너리 모든 값 출력.
	+ ![image](https://user-images.githubusercontent.com/77817094/195982450-1b92f77b-a04b-437b-84f9-c8ff7bcdd660.png)

# 🥽반복문🥽

## while문
``` 코드로 대체 ```  

## for문
``` 코드로 대체 ```   

### range() 함수  
-> range(시작값, 멈춤값, 연속하는 두 수의 차)

## if문
``` 코드로 대체 ``` 

# 🎁모듈과 패키지🎁
## 모듈🧀
``` 파이썬에서는 개별 소스 파일을 일컫는 말 ```   
* 모듈 : 독자적인 기능을 갖는 구성 요소  
* 표준 모듈 : 파이썬과 함께 따라오는 모듈  
* 사용자 생성 모듈 : 프로그래머가 직접 작성한 모듈  
* 서드 파티 모듈 : 업체 또는 다른 프로그래머에서 제공한 모듈  


**import의 역할**  
``` 두 개의 소스 파일(모듈)로 하나의 프로그램 만들기 ```  
* 다른 모듈 내의 코드에 대한 접근을 가능하게 함  
* 다른 코드에는 함수, 클래스 등이 포함되어 있음.
* 사용법: 
	* import calculator  
	* from calculator import plus
	* 코드로 대체  

**메인 모듈**
``` 최상위 수준으로 실행되는 스크립트 ```
__name__ : __main__ 으로 뜸.

## 패키지🧀  
``` 모듈 꾸러미 ```
* 모듈을 모아놓는 디렉토리
* 디렉토리가 "파이썬의 패키지"로 인정받으려면 __init__.py 파일을 그 경로에 갖고 있어야 함.  
	* 보통의 경우 init__.py 파일은 대개 비워둠